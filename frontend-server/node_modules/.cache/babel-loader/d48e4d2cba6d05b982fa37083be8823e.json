{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events = require(\"events\");\n\nconst WebSocket = require(\"ws\");\n\nconst polygon = require('./polygonWebsocket');\n\nconst entity = require('./entity'); // Listeners\n// A client can listen on any of the following events, states, or errors\n// Connection states. Each of these will also emit EVENT.STATE_CHANGE\n\n\nvar STATE;\n\n(function (STATE) {\n  STATE.AUTHENTICATING = \"authenticating\";\n  STATE.CONNECTED = \"connected\";\n  STATE.CONNECTING = \"connecting\";\n  STATE.DISCONNECTED = \"disconnected\";\n  STATE.WAITING_TO_CONNECT = \"waiting to connect\";\n  STATE.WAITING_TO_RECONNECT = \"waiting to reconnect\";\n})(STATE = exports.STATE || (exports.STATE = {})); // Client events\n\n\nvar EVENT;\n\n(function (EVENT) {\n  EVENT.CLIENT_ERROR = \"client error\";\n  EVENT.STATE_CHANGE = \"state change\";\n  EVENT.AUTHORIZED = \"authorized\";\n  EVENT.UNAUTHORIZED = \"unauthorized\";\n  EVENT.ORDER_UPDATE = \"trade_updates\";\n  EVENT.ACCOUNT_UPDATE = \"account_updates\";\n  EVENT.STOCK_TRADES = \"stock_trades\";\n  EVENT.STOCK_QUOTES = \"stock_quotes\";\n  EVENT.STOCK_AGG_SEC = \"stock_agg_sec\";\n  EVENT.STOCK_AGG_MIN = \"stock_agg_min\";\n})(EVENT = exports.EVENT || (exports.EVENT = {})); // Connection errors Each of these will also emit EVENT.ERROR\n\n\nvar ERROR;\n\n(function (ERROR) {\n  ERROR.BAD_KEY_OR_SECRET = \"bad key id or secret\";\n  ERROR.CONNECTION_REFUSED = \"connection refused\";\n  ERROR.MISSING_API_KEY = \"missing api key\";\n  ERROR.MISSING_SECRET_KEY = \"missing secret key\";\n  ERROR.UNKNOWN = \"unknown error\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\n/**\n * AlpacaStreamClient manages a connection to Alpaca's websocket api\n */\n\n\nclass AlpacaStreamClient extends events.EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this.defaultOptions = {\n      // A list of subscriptions to subscribe to on connection\n      subscriptions: [],\n      // Whether the library should reconnect automatically\n      reconnect: true,\n      // Reconnection backoff: if true, then the reconnection time will be initially\n      // reconnectTimeout, then will double with each unsuccessful connection attempt.\n      // It will not exceed maxReconnectTimeout\n      backoff: true,\n      // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false\n      reconnectTimeout: 0,\n      // The maximum amount of time between reconnect tries (applies to backoff)\n      maxReconnectTimeout: 30,\n      // The amount of time to increment the delay between each reconnect attempt\n      backoffIncrement: 0.5,\n      // If true, client outputs detailed log messages\n      verbose: false,\n      // If true we will use the polygon ws data source, otherwise we use\n      // alpaca ws data source\n      usePolygon: false\n    }; // Set minimum reconnectTimeout of 1s if backoff=false\n\n    if (!opts.backoff && opts.reconnectTimeout < 1) {\n      opts.reconnectTimeout = 1;\n    } // Merge supplied options with defaults\n\n\n    this.session = Object.assign(this.defaultOptions, opts);\n    this.session.url = this.session.url.replace(/^http/, \"ws\") + \"/stream\";\n\n    if (this.session.apiKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_API_KEY);\n    }\n\n    if (this.session.secretKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_SECRET_KEY);\n    } // Keep track of subscriptions in case we need to reconnect after the client\n    // has called subscribe()\n\n\n    this.subscriptionState = {};\n    this.session.subscriptions.forEach(x => {\n      this.subscriptionState[x] = true;\n    });\n    this.currentState = STATE.WAITING_TO_CONNECT; // Register internal event handlers\n    // Log and emit every state change\n\n    Object.keys(STATE).forEach(s => {\n      this.on(STATE[s], () => {\n        this.currentState = STATE[s];\n        this.log(\"info\", `state change: ${STATE[s]}`);\n        this.emit(EVENT.STATE_CHANGE, STATE[s]);\n      });\n    }); // Log and emit every error\n\n    Object.keys(ERROR).forEach(e => {\n      this.on(ERROR[e], () => {\n        this.log(\"error\", ERROR[e]);\n        this.emit(EVENT.CLIENT_ERROR, ERROR[e]);\n      });\n    }); // Create Polygon event emitter for callback registration\n\n    this.polygon = new polygon.PolygonWebsocket(this.session.apiKey, this.session);\n  }\n\n  connect() {\n    // Reset reconnectDisabled since the user called connect() again\n    this.reconnectDisabled = false;\n    this.emit(STATE.CONNECTING);\n    this.conn = new WebSocket(this.session.url);\n    this.conn.once(\"open\", () => {\n      this.authenticate();\n    });\n    this.conn.on(\"message\", data => this.handleMessage(data));\n    this.conn.once(\"error\", err => {\n      this.emit(ERROR.CONNECTION_REFUSED);\n    });\n    this.conn.once(\"close\", () => {\n      this.emit(STATE.DISCONNECTED);\n\n      if (this.session.reconnect && !this.reconnectDisabled) {\n        this.reconnect();\n      }\n    });\n  }\n\n  _ensure_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.subscribe(channels);\n      }\n\n      return;\n    }\n\n    this.polygon.connect(channels);\n  }\n\n  _unsubscribe_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.unsubscribe(channels);\n      }\n    }\n  }\n\n  subscribe(keys) {\n    let wsChannels = [];\n    let polygonChannels = [];\n    keys.forEach(key => {\n      const poly = ['Q.', 'T.', 'A.', 'AM.'];\n      let found = poly.filter(channel => key.startsWith(channel));\n\n      if (found.length > 0) {\n        polygonChannels.push(key);\n      } else {\n        wsChannels.push(key);\n      }\n    });\n\n    if (wsChannels.length > 0) {\n      const subMsg = {\n        action: 'listen',\n        data: {\n          streams: wsChannels\n        }\n      };\n      this.send(JSON.stringify(subMsg));\n    }\n\n    if (polygonChannels.length > 0) {\n      this._ensure_polygon(polygonChannels);\n    }\n\n    keys.forEach(x => {\n      this.subscriptionState[x] = true;\n    });\n  }\n\n  unsubscribe(keys) {\n    // Currently, only Polygon channels can be unsubscribed from\n    let polygonChannels = [];\n    keys.forEach(key => {\n      const poly = ['Q.', 'T.', 'A.', 'AM.'];\n      let found = poly.filter(channel => key.startsWith(channel));\n\n      if (found.length > 0) {\n        polygonChannels.push(key);\n      }\n    });\n\n    if (polygonChannels.length > 0) {\n      this._unsubscribe_polygon(polygonChannels);\n    }\n\n    keys.forEach(x => {\n      this.subscriptionState[x] = false;\n    });\n  }\n\n  subscriptions() {\n    // if the user unsubscribes from certain equities, they will still be\n    // under this.subscriptionState but with value \"false\", so we need to\n    // filter them out\n    return Object.keys(this.subscriptionState).filter(x => this.subscriptionState[x]);\n  }\n\n  onConnect(fn) {\n    this.on(STATE.CONNECTED, () => fn());\n  }\n\n  onDisconnect(fn) {\n    this.on(STATE.DISCONNECTED, () => fn());\n  }\n\n  onStateChange(fn) {\n    this.on(EVENT.STATE_CHANGE, newState => fn(newState));\n  }\n\n  onError(fn) {\n    this.on(EVENT.CLIENT_ERROR, err => fn(err));\n  }\n\n  onOrderUpdate(fn) {\n    this.on(EVENT.ORDER_UPDATE, orderUpdate => fn(orderUpdate));\n  }\n\n  onAccountUpdate(fn) {\n    this.on(EVENT.ACCOUNT_UPDATE, accountUpdate => fn(accountUpdate));\n  }\n\n  onPolygonConnect(fn) {\n    this.polygon.on(STATE.CONNECTED, () => fn());\n  }\n\n  onPolygonDisconnect(fn) {\n    this.polygon.on(STATE.DISCONNECTED, () => fn());\n  }\n\n  onStockTrades(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_TRADES, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  onStockQuotes(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_QUOTES, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  onStockAggSec(fn) {\n    this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) {\n      fn(subject, data);\n    });\n  }\n\n  onStockAggMin(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  send(data) {\n    this.conn.send(data);\n  }\n\n  disconnect() {\n    this.reconnectDisabled = true;\n    this.conn.close();\n\n    if (this.polygon) {\n      this.polygon.close();\n    }\n  }\n\n  state() {\n    return this.currentState;\n  }\n\n  get(key) {\n    return this.session[key];\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (this.session.backoff) {\n        this.session.reconnectTimeout += this.session.backoffIncrement;\n\n        if (this.session.reconnectTimeout > this.session.maxReconnectTimeout) {\n          this.session.reconnectTimeout = this.session.maxReconnectTimeout;\n        }\n      }\n\n      this.connect();\n    }, this.session.reconnectTimeout * 1000);\n    this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);\n  }\n\n  authenticate() {\n    this.emit(STATE.AUTHENTICATING);\n    const authMsg = {\n      action: 'authenticate',\n      data: {\n        key_id: this.session.apiKey,\n        secret_key: this.session.secretKey\n      }\n    };\n    this.send(JSON.stringify(authMsg));\n  }\n\n  handleMessage(data) {\n    // Heartbeat\n    const bytes = new Uint8Array(data);\n\n    if (bytes.length === 1 && bytes[0] === 1) {\n      return;\n    }\n\n    let message = JSON.parse(data);\n    const subject = message.stream;\n\n    if ('error' in message.data) {\n      console.log(message.data.error);\n    }\n\n    switch (subject) {\n      case \"authorization\":\n        this.authResultHandler(message.data.status);\n        break;\n\n      case \"listening\":\n        this.log(`listening to the streams: ${message.data.streams}`);\n        break;\n\n      case \"trade_updates\":\n        this.emit(EVENT.ORDER_UPDATE, message.data);\n        break;\n\n      case \"account_updates\":\n        this.emit(EVENT.ACCOUNT_UPDATE, message.data);\n        break;\n\n      default:\n        if (message.stream.startsWith('T.')) {\n          this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data));\n        } else if (message.stream.startsWith('Q.')) {\n          this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data));\n        } else if (message.stream.startsWith('AM.')) {\n          this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data));\n        } else {\n          this.emit(ERROR.PROTOBUF);\n        }\n\n    }\n  }\n\n  authResultHandler(authResult) {\n    switch (authResult) {\n      case 'authorized':\n        this.emit(STATE.CONNECTED);\n        break;\n\n      case 'unauthorized':\n        this.emit(ERROR.BAD_KEY_OR_SECRET);\n        this.disconnect();\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  log(level, ...msg) {\n    if (this.session.verbose) {\n      console[level](...msg);\n    }\n  }\n\n}\n\nexports.AlpacaStreamClient = AlpacaStreamClient;","map":{"version":3,"sources":["D:/Desktop - Data/School/Stock Bot/AlgorithmicTradingBot/frontend-server/node_modules/@alpacahq/alpaca-trade-api/lib/resources/websockets.js"],"names":["Object","defineProperty","exports","value","events","require","WebSocket","polygon","entity","STATE","AUTHENTICATING","CONNECTED","CONNECTING","DISCONNECTED","WAITING_TO_CONNECT","WAITING_TO_RECONNECT","EVENT","CLIENT_ERROR","STATE_CHANGE","AUTHORIZED","UNAUTHORIZED","ORDER_UPDATE","ACCOUNT_UPDATE","STOCK_TRADES","STOCK_QUOTES","STOCK_AGG_SEC","STOCK_AGG_MIN","ERROR","BAD_KEY_OR_SECRET","CONNECTION_REFUSED","MISSING_API_KEY","MISSING_SECRET_KEY","UNKNOWN","AlpacaStreamClient","EventEmitter","constructor","opts","defaultOptions","subscriptions","reconnect","backoff","reconnectTimeout","maxReconnectTimeout","backoffIncrement","verbose","usePolygon","session","assign","url","replace","apiKey","length","oauth","Error","secretKey","subscriptionState","forEach","x","currentState","keys","s","on","log","emit","e","PolygonWebsocket","connect","reconnectDisabled","conn","once","authenticate","data","handleMessage","err","_ensure_polygon","channels","connectCalled","subscribe","_unsubscribe_polygon","unsubscribe","wsChannels","polygonChannels","key","poly","found","filter","channel","startsWith","push","subMsg","action","streams","send","JSON","stringify","onConnect","fn","onDisconnect","onStateChange","newState","onError","onOrderUpdate","orderUpdate","onAccountUpdate","accountUpdate","onPolygonConnect","onPolygonDisconnect","onStockTrades","subject","onStockQuotes","onStockAggSec","onStockAggMin","disconnect","close","state","get","setTimeout","authMsg","key_id","secret_key","bytes","Uint8Array","message","parse","stream","console","error","authResultHandler","status","AlpacaTrade","AlpacaQuote","AggMinuteBar","PROTOBUF","authResult","level","msg"],"mappings":"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","sourcesContent":["\"use strict\"\nObject.defineProperty(exports, \"__esModule\", { value: true })\nconst events = require(\"events\")\nconst WebSocket = require(\"ws\")\nconst polygon = require('./polygonWebsocket')\nconst entity = require('./entity')\n\n// Listeners\n// A client can listen on any of the following events, states, or errors\n// Connection states. Each of these will also emit EVENT.STATE_CHANGE\nvar STATE\n(function (STATE) {\n  STATE.AUTHENTICATING = \"authenticating\"\n  STATE.CONNECTED = \"connected\"\n  STATE.CONNECTING = \"connecting\"\n  STATE.DISCONNECTED = \"disconnected\"\n  STATE.WAITING_TO_CONNECT = \"waiting to connect\"\n  STATE.WAITING_TO_RECONNECT = \"waiting to reconnect\"\n})(STATE = exports.STATE || (exports.STATE = {}))\n// Client events\nvar EVENT\n(function (EVENT) {\n  EVENT.CLIENT_ERROR = \"client error\"\n  EVENT.STATE_CHANGE = \"state change\"\n\n  EVENT.AUTHORIZED = \"authorized\"\n  EVENT.UNAUTHORIZED = \"unauthorized\"\n  EVENT.ORDER_UPDATE = \"trade_updates\"\n  EVENT.ACCOUNT_UPDATE = \"account_updates\"\n  EVENT.STOCK_TRADES = \"stock_trades\"\n  EVENT.STOCK_QUOTES = \"stock_quotes\"\n  EVENT.STOCK_AGG_SEC = \"stock_agg_sec\"\n  EVENT.STOCK_AGG_MIN = \"stock_agg_min\"\n})(EVENT = exports.EVENT || (exports.EVENT = {}))\n// Connection errors Each of these will also emit EVENT.ERROR\nvar ERROR\n(function (ERROR) {\n  ERROR.BAD_KEY_OR_SECRET = \"bad key id or secret\"\n  ERROR.CONNECTION_REFUSED = \"connection refused\"\n  ERROR.MISSING_API_KEY = \"missing api key\"\n  ERROR.MISSING_SECRET_KEY = \"missing secret key\"\n  ERROR.UNKNOWN = \"unknown error\"\n})(ERROR = exports.ERROR || (exports.ERROR = {}))\n\n/**\n * AlpacaStreamClient manages a connection to Alpaca's websocket api\n */\nclass AlpacaStreamClient extends events.EventEmitter {\n\n  constructor(opts = {}) {\n    super()\n    this.defaultOptions = {\n      // A list of subscriptions to subscribe to on connection\n      subscriptions: [],\n      // Whether the library should reconnect automatically\n      reconnect: true,\n      // Reconnection backoff: if true, then the reconnection time will be initially\n      // reconnectTimeout, then will double with each unsuccessful connection attempt.\n      // It will not exceed maxReconnectTimeout\n      backoff: true,\n      // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false\n      reconnectTimeout: 0,\n      // The maximum amount of time between reconnect tries (applies to backoff)\n      maxReconnectTimeout: 30,\n      // The amount of time to increment the delay between each reconnect attempt\n      backoffIncrement: 0.5,\n      // If true, client outputs detailed log messages\n      verbose: false,\n      // If true we will use the polygon ws data source, otherwise we use\n      // alpaca ws data source\n      usePolygon: false,\n    }\n    // Set minimum reconnectTimeout of 1s if backoff=false\n    if (!opts.backoff && opts.reconnectTimeout < 1) {\n      opts.reconnectTimeout = 1\n    }\n    // Merge supplied options with defaults\n    this.session = Object.assign(this.defaultOptions, opts)\n\n    this.session.url = this.session.url.replace(/^http/, \"ws\") + \"/stream\"\n    if (this.session.apiKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_API_KEY)\n    }\n    if (this.session.secretKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_SECRET_KEY)\n    }\n    // Keep track of subscriptions in case we need to reconnect after the client\n    // has called subscribe()\n    this.subscriptionState = {}\n    this.session.subscriptions.forEach(x => {\n      this.subscriptionState[x] = true\n    })\n    this.currentState = STATE.WAITING_TO_CONNECT\n    // Register internal event handlers\n    // Log and emit every state change\n    Object.keys(STATE).forEach(s => {\n      this.on(STATE[s], () => {\n        this.currentState = STATE[s]\n        this.log(\"info\", `state change: ${STATE[s]}`)\n        this.emit(EVENT.STATE_CHANGE, STATE[s])\n      })\n    })\n    // Log and emit every error\n    Object.keys(ERROR).forEach(e => {\n      this.on(ERROR[e], () => {\n        this.log(\"error\", ERROR[e])\n        this.emit(EVENT.CLIENT_ERROR, ERROR[e])\n      })\n    })\n    // Create Polygon event emitter for callback registration\n    this.polygon = new polygon.PolygonWebsocket(this.session.apiKey, this.session)\n  }\n\n  connect() {\n    // Reset reconnectDisabled since the user called connect() again\n    this.reconnectDisabled = false\n    this.emit(STATE.CONNECTING)\n    this.conn = new WebSocket(this.session.url)\n    this.conn.once(\"open\", () => {\n      this.authenticate()\n    })\n    this.conn.on(\"message\", (data) => this.handleMessage(data))\n    this.conn.once(\"error\", err => {\n      this.emit(ERROR.CONNECTION_REFUSED)\n    })\n    this.conn.once(\"close\", () => {\n      this.emit(STATE.DISCONNECTED)\n      if (this.session.reconnect && !this.reconnectDisabled) {\n        this.reconnect()\n      }\n    })\n  }\n\n  _ensure_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.subscribe(channels)\n      }\n      return\n    }\n    this.polygon.connect(channels)\n  }\n\n  _unsubscribe_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.unsubscribe(channels)\n      }\n    }\n  }\n\n  subscribe(keys) {\n    let wsChannels = []\n    let polygonChannels = []\n    keys.forEach(key => {\n      const poly = ['Q.', 'T.', 'A.', 'AM.']\n      let found = poly.filter((channel) => key.startsWith(channel))\n      if (found.length > 0) {\n        polygonChannels.push(key)\n      } else {\n        wsChannels.push(key)\n      }\n    })\n    if (wsChannels.length > 0) {\n      const subMsg = {\n        action: 'listen',\n        data: {\n          streams: wsChannels\n        }\n      }\n      this.send(JSON.stringify(subMsg))\n    }\n    if (polygonChannels.length > 0) {\n      this._ensure_polygon(polygonChannels)\n    }\n    keys.forEach(x => {\n      this.subscriptionState[x] = true\n    })\n  }\n\n  unsubscribe(keys) {\n    // Currently, only Polygon channels can be unsubscribed from\n    let polygonChannels = []\n    keys.forEach(key => {\n      const poly = ['Q.', 'T.', 'A.', 'AM.']\n      let found = poly.filter((channel) => key.startsWith(channel))\n      if (found.length > 0) {\n        polygonChannels.push(key)\n      }\n    })\n    if (polygonChannels.length > 0) {\n      this._unsubscribe_polygon(polygonChannels)\n    }\n    keys.forEach(x => {\n      this.subscriptionState[x] = false\n    })\n  }\n\n  subscriptions() {\n    // if the user unsubscribes from certain equities, they will still be\n    // under this.subscriptionState but with value \"false\", so we need to\n    // filter them out\n    return Object.keys(this.subscriptionState).filter(\n        x => this.subscriptionState[x])\n  }\n\n  onConnect(fn) {\n    this.on(STATE.CONNECTED, () => fn())\n  }\n\n  onDisconnect(fn) {\n    this.on(STATE.DISCONNECTED, () => fn())\n  }\n\n  onStateChange(fn) {\n    this.on(EVENT.STATE_CHANGE, newState => fn(newState))\n  }\n\n  onError(fn) {\n    this.on(EVENT.CLIENT_ERROR, err => fn(err))\n  }\n\n  onOrderUpdate(fn) {\n    this.on(EVENT.ORDER_UPDATE, orderUpdate => fn(orderUpdate))\n  }\n\n  onAccountUpdate(fn) {\n    this.on(EVENT.ACCOUNT_UPDATE, accountUpdate => fn(accountUpdate))\n  }\n\n  onPolygonConnect(fn) {\n    this.polygon.on(STATE.CONNECTED, () => fn())\n  }\n\n  onPolygonDisconnect(fn) {\n    this.polygon.on(STATE.DISCONNECTED, () => fn())\n  }\n\n  onStockTrades(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) { fn(subject, data) })\n    } else {\n      this.on(EVENT.STOCK_TRADES, function (subject, data) { fn(subject, data) })\n    }\n  }\n\n  onStockQuotes(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) { fn(subject, data) })\n    } else {\n      this.on(EVENT.STOCK_QUOTES, function (subject, data) { fn(subject, data) })\n    }\n  }\n\n  onStockAggSec(fn) {\n    this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) { fn(subject, data) })\n  }\n\n  onStockAggMin(fn) {\n     if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) { fn(subject, data) })\n    } else {\n      this.on(EVENT.STOCK_AGG_MIN, function (subject, data) { fn(subject, data) })\n    }\n  }\n\n  send(data) {\n    this.conn.send(data)\n  }\n\n  disconnect() {\n    this.reconnectDisabled = true\n    this.conn.close()\n    if (this.polygon) {\n      this.polygon.close()\n    }\n  }\n\n  state() {\n    return this.currentState\n  }\n\n  get(key) {\n    return this.session[key]\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (this.session.backoff) {\n        this.session.reconnectTimeout += this.session.backoffIncrement\n        if (this.session.reconnectTimeout > this.session.maxReconnectTimeout) {\n          this.session.reconnectTimeout = this.session.maxReconnectTimeout\n        }\n      }\n      this.connect()\n    }, this.session.reconnectTimeout * 1000)\n    this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout)\n  }\n\n  authenticate() {\n    this.emit(STATE.AUTHENTICATING)\n\n    const authMsg = {\n      action: 'authenticate',\n      data: {\n        key_id: this.session.apiKey,\n        secret_key: this.session.secretKey\n      }\n    }\n    this.send(JSON.stringify(authMsg))\n  }\n\n  handleMessage(data) {\n    // Heartbeat\n    const bytes = new Uint8Array(data)\n    if (bytes.length === 1 && bytes[0] === 1) {\n      return\n    }\n    let message = JSON.parse(data)\n    const subject = message.stream;\n    if ('error' in message.data) {\n      console.log(message.data.error);\n    }\n    switch (subject) {\n      case \"authorization\":\n        this.authResultHandler(message.data.status)\n        break\n      case \"listening\":\n        this.log(`listening to the streams: ${message.data.streams}`)\n        break\n      case \"trade_updates\":\n        this.emit(EVENT.ORDER_UPDATE, message.data)\n        break\n      case \"account_updates\":\n        this.emit(EVENT.ACCOUNT_UPDATE, message.data)\n        break\n      default:\n        if (message.stream.startsWith('T.')) {\n          this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data))\n        } else if (message.stream.startsWith('Q.')) {\n          this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data))\n        } else if (message.stream.startsWith('AM.')) {\n          this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data))\n        } else {\n          this.emit(ERROR.PROTOBUF)\n        }\n    }\n  }\n\n  authResultHandler(authResult) {\n    switch (authResult) {\n      case 'authorized':\n        this.emit(STATE.CONNECTED)\n        break\n      case 'unauthorized':\n        this.emit(ERROR.BAD_KEY_OR_SECRET)\n        this.disconnect()\n        break\n      default:\n        break\n    }\n  }\n\n  log(level, ...msg) {\n    if (this.session.verbose) {\n      console[level](...msg)\n    }\n  }\n}\nexports.AlpacaStreamClient = AlpacaStreamClient\n"]},"metadata":{},"sourceType":"script"}